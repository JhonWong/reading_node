### Item 3. Use Const 

const对于迭代器的作用与其对指针的作用相同

使用const修饰指针时，首先对用户来说是很容易理解的，用户马上就可以认出来哪些函数不会去修改类成员。

如果有时候需要在const函数中修改某个函数的值，那么可以使用mutable关键字

```c++
class CTextBlock {
public:
...
std::size_t length() const;
private:
char * pText;
mutable std::size_t textLength; 		// these data members may
mutable bool lengthIsValid; 			// always be modified, even in
}; 										// const member functions
std::size_t CTextBlock::length() const
{
if (!lengthIsValid) {
textLength = std::strlen(pText); 		// now fine
lengthIsValid = true; 					// also fine
}
return textLength;
}
```

**避免代码重复**

```c++
class TextBlock {
public:
...
const char& operator[](std::size_t position) const
{
... // do bounds checking
... // log access data
... // verify data integrity
return text[position];
}
char& operator[](std::size_t position)
{
... // do bounds checking
... // log access data
... // verify data integrity
return text[position];
}
private:
std::string text;
};
```

有时候operator函数并不只是返回一系列的值，它还可能执行一些别的动作的时候。写两个版本的重载函数就会使代码过于重复，并且不利于维护。可能直觉的想法是将重复的部分放入另一个函数中，但是这样还是重复调用了一些代码。比如函数调用，以及return返回。

好的做法是使用常量性转移：

```c++
const char& operator[](std::size_t position) const // same as before
{
...
...
...
return text[position];
}
char& operator[](std::size_t position) // now just calls const op[]
{
return
const_cast<char&>( 						// cast away const on
										// op[]’s return type;
static_cast<const TextBlock&>( * this) // add const to * this’s type;
[position] 								// call const version of op[]
);
}
```

第一次是为函数调用加上const，第二次是为返回值去掉const.





### Item 4. 使用前初始化

c和c++规则不同，所以不进行初始化时，变量的初值是不能保证的。

注意区分初始化与赋值的两个行为。

```c++
class PhoneNumber { ... };
class ABEntry { 				// ABEntry = “Address Book Entry”
public:
ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones);
private:
std::string theName;
std::string theAddress;
std::list<PhoneNumber> thePhones;
int numTimesConsulted;
};
ABEntry::ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones)
{
theName = name; 				// these are all assignments ,
theAddress = address; 			// not initializations
thePhones = phones;
numTimesConsulted = 0;
}
```

```c++
ABEntry::ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones)
: theName(name),
theAddress(address), 			// these are now all initializations
thePhones(phones),
numTimesConsulted(0)
{}								 // the ctor body is now empty
```

对于有些成员，可以统一的将初始化的操作放在一个函数中供构造函数调用。

c++的初始化顺序是有规定的，基类总是在派生类之前调用，声明早的成员更早的被调用。

### Chapter 1：Accustoming Yourself to C++

#### Item1: View C++ as federation to C++

The easiest way is to view C++ not as a single language but as a federation of related languages. Within a particular sublanguage, the rules tend to be simple, straightforward, and easy to remember. When you move from one sublanguage to another, however, the rules may change. To make sense of C++, you have to recognize its primary sublanguages.

- **C.**the rules for effective programming reflect C’s more limited scope: no templates, no exceptions, no overloading, etc.
- **Object-Oriented C++.**This part of C++ is what C with Classes was all about: classes (including constructors and destructors), encapsulation, inheritance, polymorphism, virtual functions (dynamic binding), etc. 
- **Template C++.**In fact, templates are so powerful, they give rise to a completely new programming paradigm, template metaprogramming (TMP).
- **The STL.**The STL has particular ways of doing things, and when you’re working with the STL, you need to be sure to follow its conventions.

For example, pass-by-value is generally more efficient than pass-by-reference for built-in (i.e., C-like) types, but when you move from the C part of C++ to Object-Oriented C++, the existence of user-defined constructors and destructors means that pass-by-reference-to- const is usually better. This is especially the case when working in Template C++, because there, you don’t even know the type of object you’re dealing with. When you cross into the STL, however, you know that iterators and function objects are modeled on pointers in C, so for iterators and function objects in the STL, the old C pass-by-value rule applies again.

#### Item 2: Prefer const s, enum s, and inline s to #defines.

**Const.** 

```c++
#define ASPECT_RATIO 1.653
```

it may be removed by the preprocessor before the source code ever gets to a compiler. As a result, the name ASPECT_RATIO may not get entered into the symbol table. This can be confusing if you get an error during compilation involving the use of the constant, because the error message may refer to 1.653 , not ASPECT_RATIO . If ASPECT_RATIO were defined in a header file you didn’t write, you’d have no idea where that 1.653 came from, and you’d waste time tracking it down. This problem can also crop up in a symbolic debugger, because, again, the name you’re programming with may not be in the symbol table.

```c++
const double AspectRatio = 1.653; 
```

use of the constant may yield smaller code than using a #define . That’s because the pre processor’s blind substitution of the macro name ASPECT_RATIO with 1.653 could result in multiple copies of 1.653 in your object code, while the use of the constant AspectRatio should never result in more than one copy.

**enum.**

This Item might better be called “prefer the compiler to the preprocessor,” because #define may be treated as if it’s not part of the language per se. 

```c++
class GamePlayer {
private:
static const int NumTurns = 5; // constant declaration
int scores[NumTurns]; // use of constant
...
};
```

```c++
class CostEstimate {
private:
static const double FudgeFactor; // declaration of static class
... // constant; goes in header file
};
const double // definition of static class
CostEstimate::FudgeFactor = 1.35; // constant; goes in impl. file
```

```c++
class GamePlayer {
private:
enum { NumTurns = 5 }; // “the enum hack” — makes
// NumTurns a symbolic name for 5
int scores[NumTurns]; // fine
...
};
```

First, the enum hack behaves in some ways more like a #define than a const does, and sometimes that’s what you want. For example, it’s legal to take the address of a const , but it’s not legal to take the address of an enum, and it’s typically not legal to take the address of a #define , either.

```c++
// call f with the maximum of a and b
#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
```

```c++
template<typename T> // because we don’t
inline void callWithMax(const T& a, const T& b) // know what T is, we
{ // pass by reference-to-
f(a > b ? a : b); // const — see Item 20
}
```

Given the availability of const s, enum s, and inline s, your need for the preprocessor (especially #define ) is reduced, but it’s not eliminated. #include remains essential, and #ifdef / #ifndef continue to play important roles in controlling compilation. It’s not yet time to retire the preprocessor, but you should definitely give it long and frequent vacations.

**Things to Remember**
✦ For simple constants, prefer const objects or enums to #define s.
✦ For function-like macros, prefer inline functions to #define s.

#### Item 3: Use const whenever possible.

```c++
char greeting[] = "Hello";
char * p = greeting; // non-const pointer,
					// non-const data
const char * p = greeting; // non-const pointer,
						// const data
char * const p = greeting; // const pointer,
						// non-const data
const char * const p = greeting; // const pointer,
							  // const data
```

Declaring an iterator const is like declaring a pointer const(i.e., declaring a T * const pointer): the iterator isn’t allowed to point to something different, but the thing it points to may be modified.

```c++
std::vector<int> vec;
...
const std::vector<int>::iterator iter = // iter acts like a T * const
	vec.begin();
* iter = 10;
									// OK, changes what iter points to
++iter; 							// error! iter is const
std::vector<int>::const_iterator cIter = // cIter acts like a const T *
	vec.begin();
* cIter = 10;
									// error! * cIter is const
++cIter; 							// fine, changes cIter
```

Some of the most powerful uses of const stem from its application to function declarations. 

**const Member Functions**

The purpose of const on member functions is to identify which member functions may be invoked on const objects.  First, they make the interface of a class easier to understand. It’s important to know which functions may modify an object and which may not. 

```c++
if (a * b = c) ... // oops, meant to do a comparison!
```

**const Member Functions**

```c++
class TextBlock {
public:
...
const char& operator[](std::size_t position) const // operator[] for
{ return text[position]; } 						// const objects
char& operator[](std::size_t position) 			// operator[] for
{ return text[position]; } 						// non-const objects
private:
std::string text;
};

```

TextBlock ’s operator[] s can be used like this:

```c++
TextBlock tb("Hello");
std::cout << tb[0]; 								// calls non-const
												// TextBlock::operator[]
const TextBlock ctb("World");
std::cout << ctb[0]; 							// calls const TextBlock::operator[]
```

There are two prevailing notions: bitwise constness (also known as physical constness) and logical constness.

```c++
class CTextBlock {
public:
...
std::size_t length() const;
private:
char * pText;
std::size_t textLength; 		// last calculated length of textblock
bool lengthIsValid; 			// whether length is currently valid
};
std::size_t CTextBlock::length() const
{
if (!lengthIsValid) {
textLength = std::strlen(pText); // error! can’t assign to textLength
lengthIsValid = true; 			// and lengthIsValid in a const
} 							  // member function
return textLength;
}
```



















#### Item 4: Make sure that objects are initialized before they’re used.
