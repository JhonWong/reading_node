### Item 3. Use Const 

const对于迭代器的作用与其对指针的作用相同

使用const修饰指针时，首先对用户来说是很容易理解的，用户马上就可以认出来哪些函数不会去修改类成员。

如果有时候需要在const函数中修改某个函数的值，那么可以使用mutable关键字

```c++
class CTextBlock {
public:
...
std::size_t length() const;
private:
char * pText;
mutable std::size_t textLength; 		// these data members may
mutable bool lengthIsValid; 			// always be modified, even in
}; 										// const member functions
std::size_t CTextBlock::length() const
{
if (!lengthIsValid) {
textLength = std::strlen(pText); 		// now fine
lengthIsValid = true; 					// also fine
}
return textLength;
}
```

**避免代码重复**

```c++
class TextBlock {
public:
...
const char& operator[](std::size_t position) const
{
... // do bounds checking
... // log access data
... // verify data integrity
return text[position];
}
char& operator[](std::size_t position)
{
... // do bounds checking
... // log access data
... // verify data integrity
return text[position];
}
private:
std::string text;
};
```

有时候operator函数并不只是返回一系列的值，它还可能执行一些别的动作的时候。写两个版本的重载函数就会使代码过于重复，并且不利于维护。可能直觉的想法是将重复的部分放入另一个函数中，但是这样还是重复调用了一些代码。比如函数调用，以及return返回。

好的做法是使用常量性转移：

```c++
const char& operator[](std::size_t position) const // same as before
{
...
...
...
return text[position];
}
char& operator[](std::size_t position) // now just calls const op[]
{
return
const_cast<char&>( 						// cast away const on
										// op[]’s return type;
static_cast<const TextBlock&>( * this) // add const to * this’s type;
[position] 								// call const version of op[]
);
}
```

第一次是为函数调用加上const，第二次是为返回值去掉const.





### Item 4. 使用前初始化

c和c++规则不同，所以不进行初始化时，变量的初值是不能保证的。

注意区分初始化与赋值的两个行为。

```c++
class PhoneNumber { ... };
class ABEntry { 				// ABEntry = “Address Book Entry”
public:
ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones);
private:
std::string theName;
std::string theAddress;
std::list<PhoneNumber> thePhones;
int numTimesConsulted;
};
ABEntry::ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones)
{
theName = name; 				// these are all assignments ,
theAddress = address; 			// not initializations
thePhones = phones;
numTimesConsulted = 0;
}
```

```c++
ABEntry::ABEntry(const std::string& name, const std::string& address,
const std::list<PhoneNumber>& phones)
: theName(name),
theAddress(address), 			// these are now all initializations
thePhones(phones),
numTimesConsulted(0)
{}								 // the ctor body is now empty
```

对于有些成员，可以统一的将初始化的操作放在一个函数中供构造函数调用。

c++的初始化顺序是有规定的，基类总是在派生类之前调用，声明早的成员更早的被调用。

